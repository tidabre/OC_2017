package game.player.pacman;

import game.core.Game;
import game.core.Game.DM;
import gui.AbstractPlayer;

public class PacmanGroup6 extends AbstractPlayer {

	@Override
	public int getAction(Game game, long timeDue) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public String getGroupName() {
		// TODO Auto-generated method stub
		return "PacmanGroup6";
	}

	private class PacmanNeuralNetwork {
		/**
		 * The Bias value to be used
		 */
		private static final float	BIAS				= 1f;

		private static final int	INPUT_COUNT			= 20;
		private static final int	OUTPUT_COUNT		= 4;
		/**
		 * Rule of Thumb: 1 Hidden layer, number of perceptrons: mean of #inputs
		 * and #outputs
		 */
		private static final int	HIDDEN_PERCEPTRONS	= (INPUT_COUNT
				+ OUTPUT_COUNT) / 2;

		private final float[][]		hiddenWeights;
		private final float[][]		outputWeights;

		public PacmanNeuralNetwork() {
			// one weight set/vector for each hidden perceptron (fully
			// connected)
			// +1 for the bias input to each neuron
			hiddenWeights = new float[HIDDEN_PERCEPTRONS][INPUT_COUNT + 1];

			// one weight vector for each output
			outputWeights = new float[OUTPUT_COUNT][HIDDEN_PERCEPTRONS + 1];

			hiddenPerceptronValues = new float[HIDDEN_PERCEPTRONS];
			outputPerceptronValues = new float[OUTPUT_COUNT];

			init();
		}

		/**
		 * Random initialization of all weights in this network.
		 */
		public void init() {
			/*
			 * Make use of the pow function to reduce probability for weight
			 * values close to 1. TODO: change?
			 */
			for (int i = 0; i < hiddenWeights.length; i++) {
				for (int j = 0; j < INPUT_COUNT + 1; j++) {
					hiddenWeights[i][j] = (float) Math.pow(Math.random(), 2);
				}
			}

			for (int i = 0; i < outputWeights.length; i++) {
				for (int j = 0; j < hiddenWeights.length + 1; j++) {
					outputWeights[i][j] = (float) Math.pow(Math.random(), 2);
				}
			}
		}

		/**
		 * Used to store perceptron values when calling output.
		 */
		private final float[]	hiddenPerceptronValues;
		/**
		 * Used to store perceptron values when calling output.
		 */
		private final float[]	outputPerceptronValues;

		/**
		 * Outputs the direction with the highest value generated by the
		 * network.
		 * 
		 * @return the desired direction (which may be invalid, since it is not
		 *         checked)
		 */
		public int output(Game game) {
			float pValue;
			for (int i = 0; i < hiddenPerceptronValues.length; i++) {
				// reset perceptronValue
				pValue = 0;

				/*
				 * for each weight and input add the product to our hidden
				 * perceptron output
				 */
				for (int w = 0; w < hiddenWeights[i].length; w++) {
					pValue += hiddenWeights[i][w] * getInput(game, w);
				}

				pValue = sigmoid(pValue);

				hiddenPerceptronValues[i] = pValue;
			}

			for (int i = 0; i < outputPerceptronValues.length; i++) {
				// reset perceptronValue
				pValue = 0;

				/*
				 * for each weight and input add the product to our hidden
				 * perceptron output use offsets to calculate bias first at
				 * position 0
				 */
				pValue += outputWeights[i][0] * BIAS;
				for (int w = 1; w < outputWeights[i].length; w++) {
					pValue += outputWeights[i][w]
							* hiddenPerceptronValues[w - 1];
				}

				pValue = sigmoid(pValue);

				outputPerceptronValues[i] = pValue;
			}

			float result = Float.NEGATIVE_INFINITY;
			int resultDirection = 0;
			for (int i = 0; i < outputPerceptronValues.length; i++) {
				if (outputPerceptronValues[i] > result) {
					result = outputPerceptronValues[i];
					resultDirection = i;
				}
			}

			return resultDirection;
		}

		/**
		 * Returns the inputs for this Pacman Neural-Net. Creates a new array of
		 * matching size, if inputArray is empty.
		 * 
		 * @param inputArray
		 *            the array to be filled with values
		 * @return inputArray or a newly created float array, if inputArray was
		 *         null
		 */
		float[] calculateInputs(Game game, float[] inputArray) {
			/*
			 * If non-existant, create a new Array.
			 */
			if (inputArray == null)
				inputArray = new float[INPUT_COUNT];

			/*
			 * Continuously increases the array index count
			 */
			int index = 0;

			for (int ghost = 0; ghost < game.NUM_GHOSTS; ghost++) {
				inputArray[index++] = game.getNextPacManDir(
						game.getCurGhostLoc(0),
						true,
						DM.PATH) == Game.LEFT ? 1 : 0;
			}

			return inputArray;
		}

		/**
		 * Returns the input for this Pacman at the requested index. It is
		 * normalized to some value between -1 and 1.
		 * 
		 * @param inputIndex
		 *            the requested index
		 * @return the input value
		 */
		float getInput(Game game, int inputIndex) {
			switch (inputIndex) {
				// Input 0 is always the BIAS value
				case 0 :
					return BIAS;
				// Ghost 0 to the left
				case 1 :
					return game.getNextPacManDir(
							game.getCurGhostLoc(0),
							true,
							DM.PATH) == Game.LEFT ? 1 : 0;
				// Ghost 0 to the right
				case 2 :
					return game.getNextPacManDir(
							game.getCurGhostLoc(0),
							true,
							DM.PATH) == Game.RIGHT ? 1 : 0;
				// Ghost 0 above
				case 3 :
					return game.getNextPacManDir(
							game.getCurGhostLoc(0),
							true,
							DM.PATH) == Game.UP ? 1 : 0;
				// Ghost 0 below
				case 4 :
					return game.getNextPacManDir(
							game.getCurGhostLoc(0),
							true,
							DM.PATH) == Game.DOWN ? 1 : 0;
				default :
					System.err
							.println(
									"No such input. Requested index: "
											+ inputIndex);
					return 0;
			}
		}

		float sigmoid(float x) {
			return (float) (1 / (1 + Math.exp(-x)));
		}
	}
}
