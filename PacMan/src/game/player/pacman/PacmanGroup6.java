package game.player.pacman;

import java.util.Arrays;
import java.util.List;

import game.core.Game;
import game.core.Game.DM;
import gui.AbstractPlayer;

public class PacmanGroup6 extends AbstractPlayer {

	PacmanNeuralNetwork			curPNN;
	List<PacmanNeuralNetwork>	generation;

	public PacmanGroup6() {
		nextNN();
	}

	@Override
	public int getAction(Game game, long timeDue) {
		// TODO Auto-generated method stub
		return curPNN.output(game);
	}

	@Override
	public String getGroupName() {
		// TODO Auto-generated method stub
		return "PacmanGroup6";
	}

	private class PacmanNeuralNetwork {
		/**
		 * The Bias value to be used
		 */
		private static final float	BIAS				= 1f;

		private static final int	INPUT_COUNT			= 48;
		private static final int	OUTPUT_COUNT		= 4;
		/**
		 * Rule of Thumb: 1 Hidden layer, number of perceptrons: mean of #inputs
		 * and #outputs
		 */
		private static final int	HIDDEN_PERCEPTRONS	= (INPUT_COUNT
				+ OUTPUT_COUNT) / 2;

		private final float[][]		hiddenWeights;
		private final float[][]		outputWeights;

		private double				score				= 0;

		public PacmanNeuralNetwork() {
			// one weight set/vector for each hidden perceptron (fully
			// connected)
			// +1 for the bias input to each neuron
			hiddenWeights = new float[HIDDEN_PERCEPTRONS][INPUT_COUNT + 1];

			// one weight vector for each output
			outputWeights = new float[OUTPUT_COUNT][HIDDEN_PERCEPTRONS + 1];

			hiddenPerceptronValues = new float[HIDDEN_PERCEPTRONS];
			outputPerceptronValues = new float[OUTPUT_COUNT];

			init();
		}

		/**
		 * Random initialization of all weights in this network.
		 */
		public void init() {
			/*
			 * Make use of the pow function to reduce probability for weight
			 * values close to 1. TODO: change?
			 */
			for (int i = 0; i < hiddenWeights.length; i++) {
				for (int j = 0; j < INPUT_COUNT + 1; j++) {
					hiddenWeights[i][j] = (float) Math.pow(Math.random(), 2);
				}
			}

			for (int i = 0; i < outputWeights.length; i++) {
				for (int j = 0; j < hiddenWeights.length + 1; j++) {
					outputWeights[i][j] = (float) Math.pow(Math.random(), 2);
				}
			}
		}

		private float[]			inputValues;
		/**
		 * Used to store perceptron values when calling output.
		 */
		private final float[]	hiddenPerceptronValues;
		/**
		 * Used to store perceptron values when calling output.
		 */
		private final float[]	outputPerceptronValues;

		/**
		 * Outputs the direction with the highest value generated by the
		 * network.
		 * 
		 * @return the desired direction (which may be invalid, since it is not
		 *         checked)
		 */
		public int output(Game game) {
			if (inputValues == null)
				inputValues = calculateInputs(game, null);
			else
				calculateInputs(game, inputValues);

			float pValue;
			for (int i = 0; i < hiddenPerceptronValues.length; i++) {
				// reset perceptronValue
				pValue = 0;

				/*
				 * for each weight and input add the product to our hidden
				 * perceptron output
				 */
				pValue += hiddenWeights[i][0] * BIAS;
				for (int w = 1; w < hiddenWeights[i].length; w++) {
					pValue += hiddenWeights[i][w] * inputValues[w - 1];
				}

				pValue = sigmoid(pValue);

				hiddenPerceptronValues[i] = pValue;
			}

			for (int i = 0; i < outputPerceptronValues.length; i++) {
				// reset perceptronValue
				pValue = 0;

				/*
				 * for each weight and input add the product to our hidden
				 * perceptron output use offsets to calculate bias first at
				 * position 0
				 */
				pValue += outputWeights[i][0] * BIAS;
				for (int w = 1; w < outputWeights[i].length; w++) {
					pValue += outputWeights[i][w]
							* hiddenPerceptronValues[w - 1];
				}

				pValue = sigmoid(pValue);

				outputPerceptronValues[i] = pValue;
			}

			float result = Float.NEGATIVE_INFINITY;
			int resultDirection = 0;
			for (int i = 0; i < outputPerceptronValues.length; i++) {
				if (outputPerceptronValues[i] > result) {
					result = outputPerceptronValues[i];
					resultDirection = i;
				}
			}

			return resultDirection;
		}

		/**
		 * Returns the inputs for this Pacman Neural-Net. Creates a new array of
		 * matching size, if inputArray is empty.
		 * 
		 * @param inputArray
		 *            the array to be filled with values
		 * @return inputArray or a newly created float array, if inputArray was
		 *         null
		 */
		float[] calculateInputs(Game game, float[] inputArray) {
			/*
			 * If non-existant, create a new Array. Else clear exisiting one.
			 */
			if (inputArray == null)
				inputArray = new float[INPUT_COUNT];
			else
				Arrays.fill(inputArray, 0);
			/*
			 * Continuously increases the array index count
			 */
			int index = 0;

			/*
			 * Store for performance - this will spare some method calls
			 */
			final int pacmanLocation = game.getCurPacManLoc();

			/*
			 * get all active pills and calculate, which one is the nearest we
			 * want to know the distance and the direction to move towards this
			 * pill
			 */
			final int[] activePills = game.getPillIndicesActive();
			final int nearestPill = game
					.getTarget(pacmanLocation, activePills, true, DM.PATH);

			inputArray[index++] = game
					.getPathDistance(pacmanLocation, nearestPill);
			inputArray[index++] = game
					.getNextPacManDir(nearestPill, true, DM.PATH);

			/*
			 * get all active power pills and proceed as with normal pills above
			 */
			final int[] activePowerPills = game.getPowerPillIndicesActive();
			final int nearestPowerPill = game
					.getTarget(pacmanLocation, activePowerPills, true, DM.PATH);

			inputArray[index++] = game
					.getPathDistance(pacmanLocation, nearestPowerPill);
			inputArray[index++] = game
					.getNextPacManDir(nearestPowerPill, true, DM.PATH);

			/*
			 * Measure, in which directions the pacman may go. Possible
			 * directions are set to 1. Otherwise, the value will stay at 0
			 */
			for (final int direction : game.getPossiblePacManDirs(true)) {
				switch (direction) {
					case Game.LEFT :
						inputArray[index] = 1;
						break;
					case Game.RIGHT :
						inputArray[index + 1] = 1;
						break;
					case Game.UP :
						inputArray[index + 2] = 1;
						break;
					case Game.DOWN :
						inputArray[index + 3] = 1;
						break;
				}
			}
			index += 4;

			for (int ghost = 0; ghost < Game.NUM_GHOSTS; ghost++) {
				final int curGhostLoc = game.getCurGhostLoc(ghost);

				// ghost left
				inputArray[index++] = game.getNextPacManDir(
						curGhostLoc,
						true,
						DM.PATH) == Game.LEFT ? 1 : 0;
				// ghost right
				inputArray[index++] = game.getNextPacManDir(
						curGhostLoc,
						true,
						DM.PATH) == Game.RIGHT ? 1 : 0;
				// ghost above
				inputArray[index++] = game.getNextPacManDir(
						curGhostLoc,
						true,
						DM.PATH) == Game.UP ? 1 : 0;
				// ghost below
				inputArray[index++] = game.getNextPacManDir(
						curGhostLoc,
						true,
						DM.PATH) == Game.DOWN ? 1 : 0;

				// ghost to left
				inputArray[index++] = curGhostLoc == Game.LEFT ? 1 : 0;
				// ghost to right
				inputArray[index++] = curGhostLoc == Game.RIGHT ? 1 : 0;
				// ghost to top
				inputArray[index++] = curGhostLoc == Game.UP ? 1 : 0;
				// ghost to bottom
				inputArray[index++] = curGhostLoc == Game.DOWN ? 1 : 0;

				// ghost distance
				inputArray[index++] = game
						.getPathDistance(pacmanLocation, curGhostLoc);
				// ghost edible time in s
				inputArray[index++] = game.getEdibleTime(ghost) / 1000f;
			}

			return inputArray;
		}

		/**
		 * Returns the input for this Pacman at the requested index. It is
		 * normalized to some value between -1 and 1.
		 * 
		 * @param inputIndex
		 *            the requested index
		 * @return the input value
		 */
		float getInput(Game game, int inputIndex) {
			switch (inputIndex) {
				// Input 0 is always the BIAS value
				case 0 :
					return BIAS;
				// Ghost 0 to the left
				case 1 :
					return game.getNextPacManDir(
							game.getCurGhostLoc(0),
							true,
							DM.PATH) == Game.LEFT ? 1 : 0;
				// Ghost 0 to the right
				case 2 :
					return game.getNextPacManDir(
							game.getCurGhostLoc(0),
							true,
							DM.PATH) == Game.RIGHT ? 1 : 0;
				// Ghost 0 above
				case 3 :
					return game.getNextPacManDir(
							game.getCurGhostLoc(0),
							true,
							DM.PATH) == Game.UP ? 1 : 0;
				// Ghost 0 below
				case 4 :
					return game.getNextPacManDir(
							game.getCurGhostLoc(0),
							true,
							DM.PATH) == Game.DOWN ? 1 : 0;
				default :
					System.err
							.println(
									"No such input. Requested index: "
											+ inputIndex);
					return 0;
			}
		}

		float sigmoid(float x) {
			return (float) (1 / (1 + Math.exp(-x)));
		}

		public double getScore() {
			return score;
		}

		public void setScore(double score) {
			this.score = score;
		}
	}

	public void score(double runExperiment) {
		// TODO Auto-generated method stub

	}

	public void nextNN() {
		curPNN = new PacmanNeuralNetwork();
		generation.a
	}

	public void nextGeneration() {
		// TODO Auto-generated method stub

	}
}
